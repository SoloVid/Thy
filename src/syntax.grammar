@top Script { statement (newline statement)* }

@skip { space | LineComment }

statement {
  FunctionDefinition |
  FunctionCallStatement |
  ConstantAssignment |
  VariableAssignment |
  Declaration |
  TypeStatement
}

FunctionDefinition {
  (kw<"export"> | kw<"private">)? kw<"async">? kw<"fun"> TypeParameters? ValueIdentifier ParameterizedType? Block
}

FunctionCallStatement {
  kw<"yield">? FunctionCall
}

FunctionCall {
  ScopedValueIdentifier TypeArguments? Arguments
}

ConstantAssignment {
  (kw<"export"> | kw<"private">)? ValueIdentifier kw<"is"> FunctionCall
}

VariableAssignment {
  ScopedValueIdentifier kw<"to"> FunctionCall
}

Declaration {
  (kw<"export"> | kw<"private">)? ValueIdentifier kw<"be"> ParameterizedType
}

Arguments {
  atomicExpression* (Block (kw<"and"> Arguments)?)?
}

atomicExpression {
  Number |
  String |
  ScopedValueIdentifier
}

Block {
  indent Script outdent
}

ScopedTypeIdentifier {
  (ValueIdentifier ".")* TypeIdentifier
}

ScopedValueIdentifier {
  (ValueIdentifier ".")* ValueIdentifier
}

ParameterizedType {
  // First identifier is the base type. Additional identifiers are type arguments.
  ScopedTypeIdentifier ScopedTypeIdentifier*
}

TypeParameters {
  TypeIdentifier*
}

TypeArguments {
  ScopedTypeIdentifier*
}

TypeStatement {
  TypeAliasDefinition |
  TypeGenericDefinition |
  TypeFunctionDefinition
}

TypeAliasDefinition {
  (kw<"export"> | kw<"private">)? kw<"type"> TypeIdentifier kw<"is"> ParameterizedType
}

TypeGenericDefinition {
  // Provides local `extends Blah` capability for generic parameters.
  kw<"type"> TypeIdentifier kw<"be"> ParameterizedType
}

TypeFunctionDefinition {
  (kw<"export"> | kw<"private">)? kw<"type"> kw<"fun"> TypeIdentifier Block
}

// Keywords

kw<term> { @specialize[@name={term}]<ValueIdentifier, term> }

@tokens {
  newline { $[\n\r] }
  space { $[ \t\n\r]+ }

  TypeIdentifier { $[A-Z]$[a-zA-Z]+ }
  ValueIdentifier { $[a-z]$[a-zA-Z]+ }

  String { "." (![.] | "..")* "." }

  RestOfLine { ![\n]* }

  "(" ")"
}

@detectDelim
