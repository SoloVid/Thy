@top Script { statement (newline statement)* }

@skip { space | LineComment }

statement {
  staticStatement |
  declaration |
  controlFlowStatement |
  complexExpression
}

staticStatement {
  definition |
  assignment |
  Comment
}

declaration {
  namespaceDeclaration |
  givenDeclaration
}

namespaceDeclaration {
  kw<"namespace"> ScopedValueIdentifier
}

givenDeclaration {
  kw<"given"> identifier+
}

definition {
  ClassDefinition |
  FunctionDefinition
}

ClassDefinition {
  kw<"export">? kw<"class"> identifier TypeList newline classBody
}

classBody {
  indent (staticStatement (newline staticStatement)*)? outdent
}

FunctionDefinition {
  kw<"export">? kw<"fun"> identifier ScopedTypeIdentifier? (identifier ScopedTypeIdentifier)* newline Block
}

TypeList {
  ScopedTypeIdentifier*
}

controlFlowStatement {
  ifStatement |
  forStatement |
  whileStatement |
  returnStatement |
  throwStatement |
  tryStatement
}

ifStatement {
  kw<"if"> oneLineExpression newline Block
  (newline kw<"and">? kw<"elseif"> oneLineExpression newline Block)*
  (newline kw<"and">? kw<"else"> newline Block)?
}

forStatement {
  kw<"for"> (ScopedValueIdentifier | Number) newline Block
}

whileStatement {
  kw<"while"> oneLineExpression newline Block
}

returnStatement {
  kw<"return"> complexExpression
}

throwStatement {
  kw<"throw"> complexExpression
}

tryStatement {
  kw<"try"> newline Block
  (newline kw<"and">? kw<"catch"> oneLineExpression newline Block)*
  (newline kw<"and">? kw<"finally"> newline Block)?
}

variableDeclaration {
  ScopedValueIdentifier kw<"will be"> ScopedTypeIdentifier
}

assignment {
  ScopedValueIdentifier ScopedTypeIdentifier? kw<"is"> complexExpression
}

complexExpression {
  instantiation |
  oneLineExpression |
  functionCallWithLambda
}

instantiation {
  ScopedTypeIdentifier ArgumentListWithLambda
}

oneLineExpression {
  specialExpression |
  simpleExpression
}

simpleExpression {
  functionCallOneLine |
  atomicExpression
}

functionCallOneLine {
  ScopedValueIdentifier ArgumentListOneLine
}

ArgumentListOneLine {
  atomicExpression*
}

functionCallWithLambda {
  ScopedValueIdentifier ArgumentList
}

ArgumentListWithLambda {
  atomicExpression* (newline lambda (newline kw<"and"> ArgumentListWithLambda)?)?
}

specialExpression {
  UnaryExpression | BinaryExpression
}

BinaryExpression {
  simpleExpression (kw<"is"> | kw<"and"> | kw<"or"> | kw<"gt"> | kw<"gte"> | kw<"lt"> | kw<"lte">) simpleExpression
}

UnaryExpression {
  kw<"not"> simpleExpression
}

atomicExpression {
  Null |
  True |
  False |
  Number |
  String |
  ScopedValueIdentifier
}

lambda { Block }

Block {
  indent statement (newline statement)* outdent
}

ScopedTypeIdentifier {
  TypeIdentifier ("." (TypeIdentifier | Number))*
}

ScopedValueIdentifier {
  ValueIdentifier ("." (ValueIdentifier | Number))*
}

// Keywords

kw<term> { @specialize[@name={term}]<identifier, term> }

@tokens {
  True { "true" }
  False { "false" }
  Null { "null" }
  newline { $[\n\r] }
  space { $[ \t\n\r]+ }

  TypeIdentifier { $[A-Z]$[a-zA-Z]+ }
  ValueIdentifier { $[a-z]$[a-zA-Z]+ }

  String { "." (![.] | "..")* "." }

  RestOfLine { ![\n]* }

  "(" ")"
}

@detectDelim
